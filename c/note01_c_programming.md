### 대표 자료형
- 정수형: int
- 실수형: double

signed에서는 overflow, underflow
unsigned에서는 Lap around

### 캐스팅
- 계산시에 항상 자동 캐스팅이 일어날 수 있다는 사실을 주의
- 삼항 연산자 (..)? A: B; 에서 A, B는 같은 타입으로 캐스팅됨
- double 계산시 계산 전에 지수부를 맞추기에 반올림 처리되는 부분이 생김
- 상수 초기화시 항상 접미사 쓰는 습관들이기(100(X), 100L(O))
- void f() 대신 void f(void)를 쓰자
(오른쪽 버전이 타입체킹됨 왼쪽처럼 하면 인수를 여러개 넣어도 에러가 안뜸)

### 함수 사용 시 권장사항
- 함수 선언부에도 변수명 쓰기
- 선언은 변수 하나당 한줄씩
- 함수의 선언과 정의는 따로 두기
(예외적으로 static은 같이도 괜찮)


[호출] -> [선언]
f(a) -> int f(int a)
실인수	형식인수
매개변수	(파라미터)
(아규먼트)

### 메모리 공간
TEXT|DATA|BSS|HEAP|STACK
이 사이 하나하나 공간을 Segment라 함

int형 10만개 이상의 자료는 stack에 저장하지 말고 전역으로

auto: internal linkage
extern: external linkage
static: internal linkage
	- extern & static은 선언한 영역 밖을 못 나감

header에 extern 쓰는 걸 추천하는 것은 선언임을 명시하는 것 
	- 보다 명확성을 위해

header에 static을 쓰는 것은 비추철


함수의 선언과 정의는 명시적으로 

unreachable code: 실행되지 못하는 코드
	- Dead code: 동작 흐름에도 포함되지 못하는 코드

리터럴 상수도 프로그램 어딘가에 저장됨
	그러나 보안등의 이유로 그 주소를 알수는 없게 되어있음.


scanf("%d %d"...)에서
	반환: 앞에서부터 제대로 읽힌 것의 갯수
	제대로 못 읽힌 순간 그 뒤는 처리도 안됨
		입력 스트림에 그대로 남음
		입력 스트림에는 '개행'까지 같이 남음
		flush가 필요(while (getchar != '\n') ;)

함수 선언시 생략된 타입은 'int'로 대체됨


복합식(연산자 우선순위가 다른 것끼리 섞인식)에서는 괄호를 쓰는 것을 권장

~: 틸드문자 / #: 해시 마크

sizeof도 원래는 괄호를 안써도 되지만 쓰는 것을 권장
```cpp
char ch = 'a';
sizeof(ch) = 1
sizeof('a') = 4
sizeof(함수호출) = 리턴값 타입(실제 호출되지는 않음)
sizeof(++a) = a가 증가되지 않음
sizeof("abcd") = 5
int intArr[4];
sizeof(Arr) = 16
```


++a의 결과가 a일수도(Visual C++), a의 복사본일 수도 있음(gcc)

조건식에는 참 거짓을 판단하는 식이 오게 하자
	if (a) {} 스타일보다 if (a!=0) {} 스타일 권장


shift 연산의 경우 unsigned에 대해서만 시행하기를 권장
	- signed는 처리계에 따라 달라질 수 있기 때문

shift는 연산 대상의 비트폭을 넘지 않게 사용할 것
	- 넘게 사용하는 것은 미정의 동작
	- 이걸 굳이 하고싶으면 루프로 한번씩 시행

--, ++는 따로 빼자
	- 전위 연산자는 앞으로 뺌, 후위 연산자는 뒤로 뺌

논리연산식의 우측에는 부작용이 없는 것을 권장
	- 부작용: 객체의 값을 변화시키는 것

else if 뒤엔 else로 끝내는게 좋음
	- 이때 아무 할 일이 없으면 공문 ';'를 넣어주자

switch-case에서
	처리문이 하나라도 있는 case에는 break를 반드시 쓰자
	default절에도 break를 넣자
		default 라벨절은 첫번째거나 마지막에 꼭 쓰자
	default 절도 반드시 쓰는 것을 권장

while, for의 제어식에는 되도록 상수를 넣지말자
	- 고의로 무한루프를 시키는 경우 제외

for, while 제어식에는 제어를 위한 식만 넣는다

for의 제어식은 0 -> N으로 순차 증가하는 것이 나음

goto:
	한 함수내에서 자유롭게 분기가 가능
	위로도 이동가능해서 편리
	난해한 코드가될 확률이 높음
	반복문 탈출용도 말고는 권장하지 않음
	다음의 두 가지를 만족할 때만 사용:
		1. goto의 도달 지점은 goto보다 아래로
		2. 상위 블럭으로만
	
fgets(str, n, stream);
	stream에서 (n-1)개 만큼 문자를 가져옴

입력시에는 항상 스트림 상태를 고려해야 함

MACRO
	- OBJECT LIKE MACRO: 매크로 상수
	- FUNCTION LIKE MACRO: 매크로 함수 -- 구별은 괄호

하드 코딩(상수를 코드에 직접 넣은 것)은 되도록 피하기

복수 구문의 매크로는 "do~while(0)" 또는 중괄호{}로 묶기

inline 함수를 실제 인라인으로 만들지 말지는 컴파일러가 결정 그래서 사용을 권하지 않음

단항 연산자 #(문자열화)와 이항 연산자 ##(토큰 결합)
'# 토큰' -> 문자열화
('# INT' = "INT")
토큰 ## 토큰 -> 하나의 토큰

문자열 두개를 연달아 쓰면 이어짐
	"Hello, " "World!" = "Hello, World!"

C에서는 자료형을 인수로 사용하는 함수를 만들 수 없음
매크로를 써야만 가능

#undef : define의 정의를 무효화한다
	- 언더바 두개로 시작하는 것들("__FILE__" 등)은 시스템이 미리 예약한 것들이므로 undef를 쓰지 말것

%p: pointer를 출력할 때 쓰는 형식문자

배열 초기화시 채우고도 남는 칸은 0으로 초기화됨;

초기화 리스트를 사용해서 초기화되는 배열 선언시 배열 사이즈를 안 적는 것을 권장

배열 초기화시 선택적 초기화 가능 ex. int a[] = {[1]=3, [3]=1,[10]=4, }

usigned long long 출력시 %llu가 맞지만 gcc는 '%I64u' 사용

대입 연산시 서로 다른 차원은 자동 캐스팅이 되지 않는다.
	- 상수는 0차원 포인터는 1차원

배열을 함수로 받고나면 배열 사이즈를 구할 수 없다(포인터로 바뀌니까)

2중 배열을 2중 포인터에 전달하지말자

주소상수와 주소상수의 +, - 결과는 첨자 차이다(단 동일한 데이터 형이어야 함)
	- 두 피연산자가 동일한 배열을 가리킬때만 쓸 것을 권장
	- 되도록 '-'만 사용할 것

되도록 주소표기(p+i) 보다는 배열 표기(p[i]) 형태로 쓸 것

배열명은 ++, --연산이 안된다

상수에는 두 가지가 있음
	- 리터럴 상수: 그 자체가 값("abcde",  10)
	- 심볼릭 상수: 값을 가리킴
		-- 매크로 상수: #define MAX 10
		-- 열거형 상수: enum {...}
		-- 상수화 변수: const 
	
### const
- const 변수의 포인터를 비const 변수에 할당하지 말 것
(const 변수는 할당이든, return이든 인자든 const로 받을 것)
- const 변수의 값은 컴파일 타임에 정해지지 않음
(switch case의 case, enum의 기호상수 값으로 사용하면 안됨)

volatile:
	변수에 대해 cash memory를 사용하지 않도록 함
	volatile은 선언된 변수가 현재 프로그램에서 바뀌지 않아도 외부 요건에 의해 바뀔 수 있음을 의미
	volatile도 const와 마찬가지로 똑같은 volatile 변수에 할당할 것

다차원 포인터
	- 이중포인터: int **p
	- 포인터배열: int *p[5]
	- 배열포인터: int (*p)[5]

함수 정의시 배열을 인자로 사용할 때 첫번째 사이즈는 비우는 것을 권장
	ex. int f(int a[3][4]) {} -> int f(int a[][4]) {}

문자열 상수가 RO데이터 영역에 저장되는 아키텍처의 경우
문자열 상수를 가리키는 포인터를 통해서 상수 변경을 할 수 없다.
	char *p = "abcde"; p[0] = 'c';

포인터배열의 sizeof: 8 * 배열 사이즈

함수 정의시 배열포인터형식 보다는 배열표기법으로 쓰는 것을 권장

### 0의 확장
- 주소 상수: NULL
- 문자 상수: '\0'
- 정수 상수: 0

### 동적할당
- realloc: 할당된 공간의 사이즈를 변경시킴
(늘리려하는데 연속 공간이 부족하면 전부를 다른 공간에 새로 할당함)
- realloc(NULL, 10);과 같은 형태로 realloc을 이용해서 동적 할당도 가능
- 동적 할당 공간을 해제한다고 해서 해당 주소를 참조하던 포인터 변수의 값이 변경되는 것은 아님
- free()를 진행한 포인터 변수는 NULL로 바꿀 것을 권장
(free(NULL)은 그냥 패스됨)
- 동적할당 후 포인터의 NULL 여부를 확인하는 것을 권장

### 배열 포인터 동적 할당
```cpp
// int arr[2][3]에 대해
(int (*)[3])malloc(sizeof(int) * 2 * 3);
```
- 배열 포인터로 할당해놓으면 해제를 한번만해도 된다는 특징이 있음


### 프로그램을 종료하는 함수
- exit(): 인자로 종료 상태를 넘김
- abort(): 파일 스트림, 동적 할당 등을 제대로 처리하지 않기때문에 사용을 비권장



댕글링 포인터: 유효하지 않은 포인터
(ex. 동적할당 후 해제된 포인터)

### 함수 포인터
```
// int func(int) {...}
int (func*)(int);
```

### 함수 포인터 배열
```cpp
int (*fpAry1D[4])(int, int) = {plus, minus, multi, plus};
int (*fpAry2D[2][2])(int, int) = {{plus, minus}, {multi, plus}};
```

### void*를 이용한 제네릭
- pointer 연산을 할 데이터 사이즈를 인자로 같이 넘겨줘야 함

### struct, 구조체
- 자기 자신을 포함하는 구조체는 만들 수 없다.
- 구조체 자체를 인자로 전달하는 행위는 메모리 오버헤드가 심함
- 구조체 태그명을 안쓰고 선언과 동시에 구조체를 만들 수 있음
```cpp
struct {
	char name[50];
	int age;
} hong;
```

### 구조체 패딩
- 구조체 맴버는 연속적으로 메모리에 할당되는 것이 아니라 2, 4, 8 단위로 이뤄짐
- 기준은 멤버 중 가장 큰 타입
- 성능 향상을 위해 사용
- 구조체 주소와 주소 연산을 이용한 멤버 접근은 하지 않는 것을 권장 

### 비트 필드(비트 단위 자료 할당)
- char는 권장하지 않음
- signed int의 비트 필드는 최소 2
- 대입시 해당 필드 최대값 안 넘게

### union, 공용체
- 엔디안 & 오해 가능성이 높으므로 사용을 권장하지 않음

### enum, 열거형 
```cpp
enum 나열형명 {
	기호상수1,
	기호상수2,
};
```
- 한번 선언된 기호상수는 추후 변경이 안됨
- 기호 상수 값을 지정할 때에는 첫번째 기호상수에만 값을 지정하거마 모든 기호 상수에 값을 저장
- 열거형 상수는 정수형이지만 매크로 상수는 타입이 없다
- enum 기호 상수가 정수기는 하지만 이 값을 받는 변수는 정수형보다는 enum으로 선언

### typedef
```
typedef '기존형의 변수선언': 이때 변수명이 새로운 재정의형의 이름이됨
```
- #define으로도 타입 재정의가 가능하긴 하지만 권장하지 않음
```cpp
#define CHAR_PTR char *

CHAR_PTR p1, p2; // p1: char*, p2: char
```
- 추상형 타입을 재정의할 때는 재정의된 타입을 쓸 것
```cpp
typedef unsigned int speed_t; 	(X)
typedef uint32 speed_t;		(O)
```
- 함수포인터의 재정의
```cpp
typedef void (*fptr)(int *, int *);
fptr f1 = swap;
```
- 배열포인터의 재정의
```cpp
typedef int (*intArrayPtr)[4];
intArrayPtr arr2d;
```

### File IO
- file open 시 file stream이 생성됨
(사실은 file 구조체가 생성됨)
- File descriptor: stdin(0) / stdout(1) / stderr(2)
- setbuf(): buffer 형태 결정
- 텍스트 파일을 제외한 파일의 복사시에는 바이너리 타입으로 파일을 open

### fread() 사용 권장 사항
- 파일 복사에 많이 씀
- 반환 값이 0일 때 다 읽어서 0인지 조금 남아서 0인지 알 수 없으므로 조심

### scanf() 
- " %c": 공백류를 무시하고 문자를 입력받음
(공백류: 1개 이상의 공백, 탭, 개행)

### freopen()


### #endif 뒤에 #ifdef 의 정보를 주석으로 씀으로써 혼란을 막을 수 있음

### 반환값이 있는 함수의 반환값은 사용할 것을 권장함

### 함수 호출 오버헤드를 고려해서 성능에 영향을 받는 반복문 안에서는 함수 호출을 자제

### 1~100 안겹치는 난수 생성
```cpp
for (i = 0; i < size; ++i) {
	arr[i] = i+1;
}
for (i = 0; i < size; ++i) {
	n = (int)rand() % size;
	swap(&arr[0], &arr[n]);
}
```

### 난수 시드의 결정
- 일부 임베디드 환경에서 난수 시드가 컴파일 타임에 결정되는 경우가 있으니 조심

### 재귀 호출
- 기본 부분(Basis part): 재귀 알고리즘을 끝내는 부분
- 유도 부분(Inductive part): 재귀적 호출 부분

```cpp
// 다음의 경우 컴파일러에 따라 첫 행만 0으로 초기화될 수도 있음
int arr[10][10] = {0};
```
