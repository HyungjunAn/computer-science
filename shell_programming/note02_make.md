### 컴파일
- 소스-(전처리)-...-(컴파일)-어셈블리어-(어셈블)-목적파일-(링커)-> 바이너리

### 오픈 소스(성당과 시장)
- 성당: 소수의 전문가만 개발에 참여
- 시장: 모든 사람이 개발에 참여

### 라이브러리
정적(static): .a(Archive / Windows에서는 lib)
- 컴파일 시 라이브러리의 기계어를 실행 파일에 포함
-장점: 배포가 용이
- 단점: 실행 파일 용량이 큼, 라이브러리 업데이트 이후 다시 컴파일 해야 함

동적(dynamic): .so(Shared Object / Windows에서는 'dll')
- 장점: 실행 파일 용량에 영향을 안 줌 / 라이브러리 업데이트 후 재컴파일이 필요 없음
- 단점: 배포가 어려움(라이브러리가 반드시 같이 제공되어야 함)

### 라이브러리 명시적 링킹 옵션: -l
- ex) $ gcc main.c -lpthread
- 시스템에서 라이브러리를 탐색하는 약속된 경로가 존재

### 헤더파일 경로 지정 옵션: -I
- ex) $ gcc -I/usr/local/myheader main.c

### 라이브러리 경로 지정 옵션: -L
- 동적 라이브러리 또는 정적 라이브러리를 탐색할 경로를 추가할 때 사용
- ex) $ gcc -L../ main.c

### 소스를 오브젝트까지만 만들어내는 옵션: -c
- ex) $ gcc -c hello1.c

### GDB 명령어
- r(Run): 실행
- b(Breakpoint)
- n(Next): 한줄씩 실행
- s(Step): 함수 호출 시 안으로 이동
- p(Print): 변수, 함수, 수식의 값 출력
- set: 변수 값, 메모리 내용 변경 가능
- x(Examine): 메모리 내용 확인
- info reg: 레지스터 값 확인

### 빌드
- 컴파일의 단위: 파일
- 소스가 많아지면 컴파일 과정이 복잡함
- 이걸 통합할 필요가 생김
- 빌드 속도 향상을 증분 빌드가 필요(+의존 관계 처리)이 필요함
- 증분 빌드: 변경된 파일만 빌드하는 기법

### Make
- 기본적으로는 Makefile, makefile을 찾음
```bash
<Target> : <Dependencies>
[tab]	<Commands>
```
- 위에서 아래로 수행
- 의존성이 없으면 해당 부분에서 종료
- 


